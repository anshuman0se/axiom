\documentclass{book}
%\newcommand{\VolumeName}{Volume 2: Axiom Users Guide}
%\input{bookheader.tex}
\pagenumbering{arabic}
\mainmatter
\setcounter{chapter}{0} % Chapter 1

\usepackage{makeidx}
\makeindex
\begin{document}
\begin{verbatim}
\start
Date: Fri, 2 Oct 2009 10:28:20 +0200 (CEST)
From: Franz Lehner
To: Tim Daly
Subject: Re: hyperdoc on the web

On Mon, 28 Sep 2009, Tim Daly wrote:
>> Hmm, I was specifically asking for a URL for domains, categories, packages, 
>> functions etc. so that one could just cut&paste a URL into a mailing-list 
>> posting.
...
> There is no particular reason why that couldn't be done.
What exactly needs to be done to get a static HTML tree
(like 
http://www.axiom-developer.org/axiom-website/hyperdoc/rootpage.xhtml
but with filled rather than empty pages:)
of the hyperdoc pages?

\start
Date: Fri, 02 Oct 2009 12:44:54 -0400
From: Tim Daly
To: Franz Lehner
Subject: Re: hyperdoc on the web

Franz Lehner wrote:
> On Mon, 28 Sep 2009, Tim Daly wrote:
>>> Hmm, I was specifically asking for a URL for domains, categories, 
>>> packages, functions etc. so that one could just cut&paste a URL into 
>>> a mailing-list posting.
> ...
>> There is no particular reason why that couldn't be done.
> What exactly needs to be done to get a static HTML tree
> (like 
> http://www.axiom-developer.org/axiom-website/hyperdoc/rootpage.xhtml
> but with filled rather than empty pages:)
> of the hyperdoc pages?
>
> regards,
> Franz
>
Most of those pages are translated from the hypertex pages.
There are additional pages on the website that are not in hypertex.

Some of the pages are dynamically generated so it would require
a working Axiom behind the server. I did create a version of these
dynamic pages using the asq function (a standalone C program that
is part of Axiom) to do the database query.

I am moving the Axiom server to a local machine so I may look into
setting up a running Axiom behind those pages.

\start
Date: Fri, 02 Oct 2009 13:29:29 -0600
From: James Onyx
To: list
Subject: "empty list" results, inverse trig substitutions, "Floats" in "solve"

I'm new to axiom, using it for calculations.  There seems to be odd behaviour
when using "solve" on a list of equations.  This is with the most recent axiom
binary package, Version Axiom (May 2009), on Ubuntu 8.10 "intrepid".  For
instance:

 (8) -> solve([a=3+x,b=1-x,x=2],[a,b])
 ...
 (8)  []
                         Type: List List Equation Fraction Polynomial Integer

So, the answer is "the empty list"?!  That's not very useful, and seems not
correct either.  What am I missing here?

Then instead:

 (9) -> solve([a=3+x,b=1-x,x=2],[a,b,x])
 (9) ->
   (9)  [[a= 5,b= - 1,x= 2]]
                         Type: List List Equation Fraction Polynomial Integer

That works.  Why?

Similarly, axiom seems confused about finding substitutions.  For instance:

 (12) -> solve([ tan(bt)=(a*r)/(s*(r-d)), x=100*cos(bt), y=d*sin(bt)],[x,y,bt])
 (12) ->
    (12)  [[]]
                                   Type: List List Equation Expression Integer

Here, "the empty list" again - why?

If, instead, I "spell it out" for axiom, by taking the arctan instead, then

 (13) -> solve([bt=atan((a*r)/(s*(r-d))),x=100*cos(bt),y=d*sin(bt)],[x,y,bt])
 (13) ->
    (13)
    [
                 (100r - 100d)s                        a d r
      [x= ----------------------------, y= ----------------------------,
           +-------------------------+      +-------------------------+
           |  2           2  2    2 2       |  2           2  2    2 2
          \|(r  - 2d r + d )s  + a r       \|(r  - 2d r + d )s  + a r
                   a r
       bt= atan(--------)]
                (r - d)s
      ]
                                   Type: List List Equation Expression Integer

Axiom doesn't know about substituting inverse trig functions by itself?

But then, again,

 (14) -> solve([bt=atan((a*r)/(s*(r-d))),x=100*cos(bt),y=d*sin(bt)],[x,y])
 (14) ->
    (14)  [[]]
                                   Type: List List Equation Expression Integer

Arrrrgh!  Ok, why is that again, returning "the empty list" when using "solve"
with the truncated list of variables?


On anther topic, "Floats" in "solve", where this works, mixing integers and
floats:

 (16) -> solve([a=3+x,b=1-x,x=2.0],[a,b,x])
    ...
    (16)  [[a= 5.0,b= - 1.0,x= 2.0]]
                            Type: List List Equation Fraction Polynomial Float

and this works:

 (17) -> solve([a=3+x,b=1-x,x=2],0.001)
   ...
   (17)  [[x= 2.0,a= 5.0,b= - 1.0]]
                                    Type: List List Equation Polynomial Float


doing this, using "x=2.0" instead of "x=2":

 (18) -> solve([a=3+x,b=1-x,x=2.0],0.001)
   ...
   There are 20 exposed and 3 unexposed library operations named solve
      having 2 argument(s) but none was determined to be applicable.
      ...
   Cannot find a definition or applicable library operation named solve
      with argument type(s)
                       List Equation Polynomial Float
                                    Float


Arrrrgh! - the dreaded "none was determined to be applicable"!
Does that make sense, that?


Thanks in advance for any clues!  Are these bugs?

\start
Date: Sat, 03 Oct 2009 14:20:56 -0400
From: William Sit
To: James Onyx
Subject: Re: "empty list" results, inverse trig	substitutions,	"Floats" in "solve"

Hi James:

When you ask Axiom to solve 

solve([a=3+x,b=1-x,x=2],[a,b])

I believe (note, this is an educated guess, but simple 
problems in Axiom can often have deep reasons, so much so 
it is difficult to understand whether things are bugs or 
features) that x is treated as a parameter, or as lying in 
the coefficient domain (usually an integral domain). All 
polynomial equations are converted into polynomial ideals 
over the coefficient domain before using the solver. Thus 
an equation like x=2 is converted to x-2 (=0), but x-2 is 
a non-zero element of the coefficient domain when x is an 
indeterminate. To solve the equation in a,b, the 
coefficient domain is extended to its field of fractions, 
and x-2 is therefore a unit in the polynomial ring with a, 
b as indeterminates. The polynomial ideal is then a unit 
ideal, hence there is no solution.

Of course, this is not what the user wants. The user wants 
to solve for a,b,x but just wants the projected part a, b 
of the solution. However, the "equation" x=2 does not 
involve a or b. If it is replaced by one that does, 
provided it forms a consistent system in the variables a, 
b with the rest (thus no single equation in x alone should 
be resulted through elimination), then the system will 
solved.

solve([a=b+x,b=a-x,x=a-3],[a,b])
[[a= x + 3,b= 3]]

If x is intended to be solved (not a parameter), then it 
should be considered as an indeterminate like a, b. 
Otherwise, if it is intended to substitute x with a value 
like 2, then it should be done after the system in a, b 
has been solved.

By distinguishing the two cases when the variables to be 
solved is [a,b] or [a,b,x], Axiom allows the user to 
indicate his intention.

I can't do much with the tan problem, since we have:

solve([tan(b) = a],[b])
>> Error detected within library code:
No identity element for reduce of empty list using 
operation
append

(You mileage may differ, since I am using a very old 
version of Axiom).

This is clearly a bug, for the old version.

William



On Fri, 02 Oct 2009 13:29:29 -0600
  James Onyx wrote:
>I'm new to axiom, using it for calculations.  There seems 
>to be odd behaviour
>when using "solve" on a list of equations.  This is with 
>the most recent axiom
>binary package, Version Axiom (May 2009), on Ubuntu 8.10 
>"intrepid".  For
>instance:
>
>  (8) -> solve([a=3+x,b=1-x,x=2],[a,b])
>  ...
>  (8)  []
>                          Type: List List Equation 
>Fraction Polynomial Integer
>
>So, the answer is "the empty list"?!  That's not very 
>useful, and seems not
>correct either.  What am I missing here?
>
>Then instead:
>
>  (9) -> solve([a=3+x,b=1-x,x=2],[a,b,x])
>  (9) ->
>    (9)  [[a= 5,b= - 1,x= 2]]
>                          Type: List List Equation 
>Fraction Polynomial Integer
>
>That works.  Why?
>
>Similarly, axiom seems confused about finding 
>substitutions.  For instance:
>
>  (12) -> solve([ tan(bt)=(a*r)/(s*(r-d)), x=100*cos(bt), 
>y=d*sin(bt)],[x,y,bt])
>  (12) ->
>     (12)  [[]]
>                                    Type: List List 
>Equation Expression Integer
>
>Here, "the empty list" again - why?
>
>If, instead, I "spell it out" for axiom, by taking the 
>arctan instead, then
>
>  (13) -> 
>solve([bt=atan((a*r)/(s*(r-d))),x=100*cos(bt),y=d*sin(bt)],[x,y,bt])
>  (13) ->
>     (13)
>     [
>                  (100r - 100d)s                        a 
>d r
>       [x= ----------------------------, y= 
>----------------------------,
>            +-------------------------+ 
>     +-------------------------+
>            |  2           2  2    2 2       |  2 
>          2  2    2 2
>           \|(r  - 2d r + d )s  + a r       \|(r  - 2d r 
>+ d )s  + a r
>                    a r
>        bt= atan(--------)]
>                 (r - d)s
>       ]
>                                    Type: List List 
>Equation Expression Integer
>
>Axiom doesn't know about substituting inverse trig 
>functions by itself?
>
>But then, again,
>
>  (14) -> 
>solve([bt=atan((a*r)/(s*(r-d))),x=100*cos(bt),y=d*sin(bt)],[x,y])
>  (14) ->
>     (14)  [[]]
>                                    Type: List List 
>Equation Expression Integer
>
>Arrrrgh!  Ok, why is that again, returning "the empty 
>list" when using "solve"
>with the truncated list of variables?
>
>
>On anther topic, "Floats" in "solve", where this works, 
>mixing integers and
>floats:
>
>  (16) -> solve([a=3+x,b=1-x,x=2.0],[a,b,x])
>     ...
>     (16)  [[a= 5.0,b= - 1.0,x= 2.0]]
>                             Type: List List Equation 
>Fraction Polynomial Float
>
>and this works:
>
>  (17) -> solve([a=3+x,b=1-x,x=2],0.001)
>    ...
>    (17)  [[x= 2.0,a= 5.0,b= - 1.0]]
>                                     Type: List List 
>Equation Polynomial Float
>
>
>doing this, using "x=2.0" instead of "x=2":
>
>  (18) -> solve([a=3+x,b=1-x,x=2.0],0.001)
>    ...
>    There are 20 exposed and 3 unexposed library 
>operations named solve
>       having 2 argument(s) but none was determined to be 
>applicable.
>       ...
>    Cannot find a definition or applicable library 
>operation named solve
>       with argument type(s)
>                        List Equation Polynomial Float
>                                     Float
>
>
>Arrrrgh! - the dreaded "none was determined to be 
>applicable"!
>Does that make sense, that?
>
>
>Thanks in advance for any clues!  Are these bugs?

\start
Date: Sat, 3 Oct 2009 14:57:15 -0400
From: Bill Page
To: William Sit
Subject: Re: "empty list" results, inverse trig substitutions, "Floats" in "solve"

On Sat, Oct 3, 2009 at 2:20 PM, William Sit wrote:
>
> I can't do much with the tan problem, since we have:
>
> solve([tan(b) = a],[b])
>>>
>>> Error detected within library code:
>
> No identity element for reduce of empty list using operation
> append
>
> (You mileage may differ, since I am using a very old version of Axiom).
>
> This is clearly a bug, for the old version.
>

Both Axiom (February 2009) and OpenAxiom (current) return

(1) -> solve([tan(b) = a],[b])

   (1)  []
                                  Type: List List Equation Expression Integer

But FriCAS gives:

wspage@debian:~$ fricas -nox

                 FriCAS (AXIOM fork) Computer Algebra System
                         Version: FriCAS 2009-09-17
            Timestamp: Wednesday September 30, 2009 at 22:17:16
-----------------------------------------------------------------------------
   Issue )copyright to view copyright notices.
   Issue )summary for a summary of useful system commands.
   Issue )quit to leave FriCAS and return to shell.
-----------------------------------------------------------------------------

(1) ->
(1) -> solve([tan(b) = a],[b])

   (1)  [[b= 0]]
                              Type: List(List(Equation(Expression(Integer))))
(2) ->

\start
Date: Sun, 04 Oct 2009 13:02:10 -0400
From: William Sit
To: James Onyx
Subject: Re: "empty list" results, inverse trig	substitutions,	"Floats" in "solve"

solve([a=3+x,b=1-x,x=2.0],0.001)

is an "incorrectly" constructed command. The "solve" 
function that was applicable in

solve([a=3+x,b=1-x,x=2],0.001)

is available for the domain List Equation Fraction 
Polynomial Integer (from the package FLOATRP) but is not 
available when Integer is replaced by Float.

According to documentation from FLOATRP, "solve(leq, eps)" 
finds all the real solutions of the system leq of 
equations of *rational* functions with respect to all the 
variables appearing in lp [sic:leq], with precision eps.

Thus, despite the package is called with FLOATRP(FLOAT), 
the leq must be from List equation Fraction Polynomial 
Integer.  I think the reason is that the package uses 
Groebner basis. See numsolve.spad for source: the 
restriction is given near the top, in package 
InnerNumericFloatingSolver (K specifies the coefficient 
field of the input polynomials and must be either Fraction 
Integer or Complex(Fraction Integer).

William


On Fri, 02 Oct 2009 13:29:29 -0600
  James Onyx wrote:
>I'm new to axiom, using it for calculations.  There seems 
>to be odd behaviour
>when using "solve" on a list of equations.  This is with 
>the most recent axiom
>binary package, Version Axiom (May 2009), on Ubuntu 8.10 
>"intrepid".  For
>instance:
>
>  (8) -> solve([a=3+x,b=1-x,x=2],[a,b])
>  ...
>  (8)  []
>                          Type: List List Equation 
>Fraction Polynomial Integer
>
>So, the answer is "the empty list"?!  That's not very 
>useful, and seems not
>correct either.  What am I missing here?
>
>Then instead:
>
>  (9) -> solve([a=3+x,b=1-x,x=2],[a,b,x])
>  (9) ->
>    (9)  [[a= 5,b= - 1,x= 2]]
>                          Type: List List Equation 
>Fraction Polynomial Integer
>
>That works.  Why?
>
>Similarly, axiom seems confused about finding 
>substitutions.  For instance:
>
>  (12) -> solve([ tan(bt)=(a*r)/(s*(r-d)), x=100*cos(bt), 
>y=d*sin(bt)],[x,y,bt])
>  (12) ->
>     (12)  [[]]
>                                    Type: List List 
>Equation Expression Integer
>
>Here, "the empty list" again - why?
>
>If, instead, I "spell it out" for axiom, by taking the 
>arctan instead, then
>
>  (13) -> 
>solve([bt=atan((a*r)/(s*(r-d))),x=100*cos(bt),y=d*sin(bt)],[x,y,bt])
>  (13) ->
>     (13)
>     [
>                  (100r - 100d)s                        a 
>d r
>       [x= ----------------------------, y= 
>----------------------------,
>            +-------------------------+ 
>     +-------------------------+
>            |  2           2  2    2 2       |  2 
>          2  2    2 2
>           \|(r  - 2d r + d )s  + a r       \|(r  - 2d r 
>+ d )s  + a r
>                    a r
>        bt= atan(--------)]
>                 (r - d)s
>       ]
>                                    Type: List List 
>Equation Expression Integer
>
>Axiom doesn't know about substituting inverse trig 
>functions by itself?
>
>But then, again,
>
>  (14) -> 
>solve([bt=atan((a*r)/(s*(r-d))),x=100*cos(bt),y=d*sin(bt)],[x,y])
>  (14) ->
>     (14)  [[]]
>                                    Type: List List 
>Equation Expression Integer
>
>Arrrrgh!  Ok, why is that again, returning "the empty 
>list" when using "solve"
>with the truncated list of variables?
>
>
>On anther topic, "Floats" in "solve", where this works, 
>mixing integers and
>floats:
>
>  (16) -> solve([a=3+x,b=1-x,x=2.0],[a,b,x])
>     ...
>     (16)  [[a= 5.0,b= - 1.0,x= 2.0]]
>                             Type: List List Equation 
>Fraction Polynomial Float
>
>and this works:
>
>  (17) -> solve([a=3+x,b=1-x,x=2],0.001)
>    ...
>    (17)  [[x= 2.0,a= 5.0,b= - 1.0]]
>                                     Type: List List 
>Equation Polynomial Float
>
>
>doing this, using "x=2.0" instead of "x=2":
>
>  (18) -> solve([a=3+x,b=1-x,x=2.0],0.001)
>    ...
>    There are 20 exposed and 3 unexposed library 
>operations named solve
>       having 2 argument(s) but none was determined to be 
>applicable.
>       ...
>    Cannot find a definition or applicable library 
>operation named solve
>       with argument type(s)
>                        List Equation Polynomial Float
>                                     Float
>
>
>Arrrrgh! - the dreaded "none was determined to be 
>applicable"!
>Does that make sense, that?
>
>
>Thanks in advance for any clues!  Are these bugs?

\start
Date: Fri, 16 Oct 2009 11:19:50 -0400
From: Tim Daly
To: William Stein
Subject: Axiom trademark and ethics

> Hi,
> 
> I looked at http://www.uspto.gov/teas/e-TEAS/index.html where one can
> 
> search for trademarks, file a trademark application, etc.  It looks
> like it costs $325.  I think filing an application for "SageMath"
> would be an appropriate use of Sage foundation funds.
>
> There is a search form here:
> http://tess2.uspto.gov/bin/gate.exe?f=tess&state=4001:pj0t1h.1.1
>
> I've only ever heard of trademarking math software in the context of
> Tim Daly remarking that "Axiom" is his registered trademark, so I
> searched Axiom first and found 103 hits -- the first I clicked on was
> for Axiom: "Providing Christian evangelistic and ministerial services
> directed towards athletes, athletic coaches and those whom they
> influence, in the sport of skateboarding".  I tried searching "Axiom
> and software" (and similar searches) but couldn't find anything about
> the Axiom math software (I just thought it would be a good example).
> 
> There are at least 359 registered trademarks that contain the word
> "Sage" in them.   Searching for just "Sage" and software yields just 5
> or so, including
>
>  http://tess2.uspto.gov/bin/showfield?f=doc&state=4001:pj0t1h.13.29
>
> which is the one for the accounting software.  Their description is:
> "Computer software for use in managing accounting and business
> information, retrieving accounting and business information, viewing
> accounting and business information, managing contacts and performing
> accounting functions in the fields of business management, information
> services, and research systems; computer software for use in
> electronic commerce to allow users to perform electronic business
> transactions via a global computer network, electronic mail, Internet
> website hosting, Internet website development, and Internet access;
> and accompanying user manual documentation for use with all of the
> above. "
>
> If there were a problem trademarking the name Sage, it would I guess
> be most likely to be because of the accounting software.
>
> The word "SageMath" does not have any entries at all in the trademark database.
>
> The point of this email is to discuss:
>
>   (1) Should we trademark SageMath (pretty obvious "yes")?
>
>   (2) Should we also trademark Sage in the context of math software,
> if possible?
>
>   (3) Is there somebody who like "legal stuff" who is willing to help
> out with the application?   Because I'm not such a person.
>
> I'm not in a hurry, but think it's about time to start moving this
> process forward.


I am not a lawyer but I DID speak to a lawyer about the Axiom
trademark. The issue of a trademark is to make sure that the
mark implies the particular product named. So the trademark is
used to identify a particular product and to protect the
reputation of that product. You do not want someone posting
bugs about "Sage" that do not apply to your software, thereby
possibly damaging the Sage reputation. Since the GPL2 allows
all of your code to be cloned, the name IS the project.

Trademarks in the United States (I have no idea how this works
in the rest of the world...) can be obtained in two ways
(according to a trademark lawyer). You can "register" a trademark
or you can use the mark in an exclusive manner for 7 years and
obtain a "common law trademark". Axiom has been unregistered
since NAG dropped the registration in 2000. It has been used in
a computer algebra sense to apply to this project since that time.
Legally, then, I am the common law holder of the Axiom trademark
as it applies to Computer Algebra software (there are, as you have
noticed, hundreds of 'Axiom' trademarks in different areas).

In either case, in order to keep a trademark, you need to defend
against any and all infringing uses of the mark or you might lose it.
You also need to keep the mark current with active use, which Axiom
does. Keeping or losing a trademark does not depend on registration.
Registration makes it easier to show that you are the holder but
you can still lose the mark if it is not actively defended.

My campaign with Sage to stop using the name "Axiom" as a command
to invoke Fricas was part of the necessary defense of the mark.
The Axiom BSD license is copyright-based and allows forking the code
but not use of the name.

Trademark is a different area of intellectual property law and
nothing in the GPL2 or BSD license allows infringing of a trademark.
You'll have the same problems when defending "Sage".

I have sent you notes about the use of "Sage" in the area
of mathematics when I have found other math software using the
same name. If another math software project uses the same name
you would have to show that you were using it first. Even then
you might not be able to be able to defend the name.

If you want a trademark you will need a unique name in the field
of use and you will need to defend it. Registration is little
more than publicly stating ownership but it is not required.

I hated consulting a real, live lawyer. It costs me time and
money I'd rather not have spent. But at this point I am reasonably
certain that I will win a trademark case.

Open source software developers all think they know the law and
every mailing list on every project seems to have the same debates
without really speaking to an expert. Yet we would laugh at lawyers
who had opinions on programming issues.

If you are going to try for a trademark (registered or common law)
talk to a lawyer first.

Rather than have the usual opinion-flamefest about trademarks and all
of the usual legal-issue-opinion-noise this will generate, you might
consider having a debate about a new project name, like "SageMath"
instead of "Sage". Your project name IS your project and you want to be
able to build (or damage) your reputation as you see fit. The last
thing you need is bug reports from some other project.

Note that except where it applies to the Axiom trademark where I have
legal advice, my opinions on trademark law are worthless.


On a related but independent topic there is the ethical issue of using
a project name. If some other math software project has been using that
name (eg "Sage") and there is a possible point of confusion then you have a
responsibility to act ethically, that is, to not do anything that would
deliberately cause confusion with another persons reputation. In fact,
you have an ethical obligation to fix any confusion that arises. For me,
ethics trumps legal issues so it is more important to "do the right thing"
because it is right than because it follows the law.

\start
Date: Wed, 28 Oct 2009 11:17:18 -0700 (PDT)
From: Tim Daly
To: list
Subject: Re: Why Did Mathematica Win?

On Oct 28, 12:32=A0pm, Mark Lawton <creamrisestothe...@gmail.com> wrote:
> There was plenty of maths software around before 1988, when
> Mathematica was released - so why did Mathematica become so dominant?
> Didn't the older software run on DOS (perhaps the other programs were
> too big to run on a 1980s PC - but if so, then they should have built
> "light" versions)? Perhaps they were too specialised? Was Mathematica
> the first to implement a GUI (graphical user interface)?
>
> What was it that allowed a start-up to beat rival software that had
> been around for over 20 years?

Axiom was known as Scratchpad at the time and started around 1971 at
IBM
Research. Scratchpad was research software and was freely available.
I sent out magnetic tapes of the sources.

We were not trying to make a commercial product. We were trying to
understand the relationship between mathematics and computers since
computational mathematics was a very new field.

We did try to market Axiom through IBM sales but the sales department
had programs that checked the required documentation to make sure it
was readable "at the 8th grade level". Clearly this was not possible.

Axiom ran on DOS, but only in my office. The DOS version was never
released. This included the X front-end graphics and help systems.

Axiom was released as a commercial product due to a drop in funding,
both from government sources and IBM directly. We eventually sold the
rights to the Numerical Algorithms Group. Axiom was one of "the big 3"
(Mathematica, Maple, and Axiom) at the time.

Axiom was withdrawn from the market in 2000 and released as open
source.

Axiom is extremely strongly typed, allowing overload selection not
only by the operand types but also by the return type. This is not yet
widely available in most languages. It is built around an algebra core
and assumes you know what mathematical concepts like "Ring" mean. The
learning curve is rather steep because you need both a strong
computational background and a strong math background. That is, you
are a computational mathematician.

\start
Date: Thu, 29 Oct 2009 13:09:54 -0500
From: Tim Daly
To: Martin Baker
Subject: Re: [Axiom-mail] finding source code

Martin Baker wrote:
>> May I ask how you found out about Axiom? What version did you
>> actually install on your computer?
>>     
>
> Ralf,
>
> I have been looking for an open source computer algebra system for some time 
> although I did not try any, I came across Axiom in lists of such systems but I 
> did not try it because (for some reason) I was put off when it said that it 
> was based on LISP.
>
> Having tried it now it works well and it seems very good (I wish I had done so 
> earlier). At first sight the user language reminds me a bit of 'Scala' in that 
> the type is given after the variable if required, also the way that brackets 
> can sometimes be omitted for what looks to me like function calls.
>
> I loaded the binary from this page:
> http://www.axiom-developer.org/axiom-website/download.html
> (suse,May2009)
>
> I recorded what I did on my web page here:
> http://www.euclideanspace.com/maths/standards/program/
>
> As you can see the program seems to work except the draw function which seems 
> to fail with:
>
>   
>>> System error:
>>>       
> Unknown bfd format
>
> The only other problem is capturing the output to put on a web page, you can 
> see what I mean about 2/3 of the way down this screen:
>
> http://www.euclideanspace.com/maths/algebra/equations/polynomial/cubic/
>
> Apart from being too big for the page, not all the LaTeX seemed to be 
> recognised (I cut and pasted from Axiom to Lyx and then did a screen shot).
>
> So, that's my experience so far, apart from these small problems it looks like 
> a very useful program.
>
> Martin
>
>
> _______________________________________________
> Axiom-mail mailing list
> Axiom-mail@nongnu.org
> http://lists.nongnu.org/mailman/listinfo/axiom-mail
>
>   
Martin,

It appears that you have an interest in documenting the use of mathematics.
Axiom is being rewritten into literate form, which means that the source 
code
is now taken directly from the books, such as bookvol10.3 which contains the
sources for the Axiom domains.

You may also find interesting examples in several places in Axiom.

1) EXAMPLES OF FUNCTION CALLS

First, there is documentation of example code use. You can type
  )display operation makeprod
and you will see the "Mappings" and some example code. In the case
of the "makeprod" function the example will look like:

  Examples of makeprod from Product

  f:(x:INT):INT +-> 3*x
  g:(x:INT):INT +-> x^3
  h(x:INT):Product(INT,INT) == makeprod(f x,g x)
  h(3)

This gives you sample input for the makeprod command.


2) FUNCTIONS FROM A DOMAIN

You have also expressed an interest in Quaternions. You can see
what functions are available for Quaternions by typing
   )show Quaternion
which gives the output shown below.


3) HELP FUNCTION

For some domains you can also type
   )help Quaternion
and see a help page for that domain with the output shown below.

Axiom is in the process of documenting all of the code. If you
would like to help, either with examples or with explanations of
areas like Quaternions that would be greatly appreciated.


4) INPUT FILES

The directory $AXIOM/input contains a large number of files
which can be read into Axiom and executed. There are examples
of quite a few domains.

5) HYPERDOC

Clearly you cannot get hyperdoc running. I am not sure what
the problem might be but if you send me email we can discuss
it further.

Tim Daly
Elder of the Internet





                        AXIOM Computer Algebra System
                       Version: Axiom (September 2009)
              Timestamp: Thursday October 29, 2009 at 06:43:59
-----------------------------------------------------------------------------
   Issue )copyright to view copyright notices.
   Issue )summary for a summary of useful system commands.
   Issue )quit to leave AXIOM and return to shell.
-----------------------------------------------------------------------------
 
   Re-reading compress.daase   Re-reading interp.daase
   Re-reading operation.daase
   Re-reading category.daase
   Re-reading browse.daase
(1) ->
(1) -> )display operation makeprod

There is one unexposed function called makeprod :
   [1] (D1,D2) -> Product(D1,D2) from Product(D1,D2)
            if D1 has SETCAT and D2 has SETCAT

Examples of makeprod from Product

f:=(x:INT):INT +-> 3*x
g:=(x:INT):INT +-> x^3
h(x:INT):Product(INT,INT) == makeprod(f x, g x)
h(3)

(1) -> )show Quaternion
 Quaternion R: CommutativeRing  is a domain constructor
 Abbreviation for Quaternion is QUAT
 This constructor is exposed in this frame.
 Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for QUAT

------------------------------- Operations --------------------------------
 ?*? : (R,%) -> %                      ?*? : (%,R) -> %
 ?*? : (%,%) -> %                      ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %        ?**? : (%,PositiveInteger) -> %
 ?+? : (%,%) -> %                      ?-? : (%,%) -> %
 -? : % -> %                           ?=? : (%,%) -> Boolean
 D : (%,(R -> R)) -> %                 D : % -> % if R has DIFRING
 1 : () -> %                           0 : () -> %
 ?^? : (%,PositiveInteger) -> %        abs : % -> R if R has RNS
 coerce : R -> %                       coerce : Integer -> %
 coerce : % -> OutputForm              conjugate : % -> %
 hash : % -> SingleInteger             imagI : % -> R
 imagJ : % -> R                        imagK : % -> R
 inv : % -> % if R has FIELD           latex : % -> String
 map : ((R -> R),%) -> %               norm : % -> R
 one? : % -> Boolean                   quatern : (R,R,R,R) -> %
 real : % -> R                         recip : % -> Union(%,"failed")
 retract : % -> R                      sample : () -> %
 zero? : % -> Boolean                  ?~=? : (%,%) -> Boolean
 ?*? : (Fraction Integer,%) -> % if R has FIELD
 ?*? : (%,Fraction Integer) -> % if R has FIELD
 ?*? : (NonNegativeInteger,%) -> %
 ?**? : (%,Integer) -> % if R has FIELD
 ?**? : (%,NonNegativeInteger) -> %
 ?<? : (%,%) -> Boolean if R has ORDSET
 ?<=? : (%,%) -> Boolean if R has ORDSET
 ?>? : (%,%) -> Boolean if R has ORDSET
 ?>=? : (%,%) -> Boolean if R has ORDSET
 D : (%,(R -> R),NonNegativeInteger) -> %
 D : (%,List Symbol,List NonNegativeInteger) -> % if R has PDRING SYMBOL
 D : (%,Symbol,NonNegativeInteger) -> % if R has PDRING SYMBOL
 D : (%,List Symbol) -> % if R has PDRING SYMBOL
 D : (%,Symbol) -> % if R has PDRING SYMBOL
 D : (%,NonNegativeInteger) -> % if R has DIFRING
 ?^? : (%,Integer) -> % if R has FIELD
 ?^? : (%,NonNegativeInteger) -> %
 characteristic : () -> NonNegativeInteger
 charthRoot : % -> Union(%,"failed") if R has CHARNZ
 coerce : Fraction Integer -> % if R has FIELD or R has RETRACT FRAC INT
 convert : % -> InputForm if R has KONVERT INFORM
 differentiate : (%,(R -> R)) -> %
 differentiate : (%,(R -> R),NonNegativeInteger) -> %
 differentiate : (%,List Symbol,List NonNegativeInteger) -> % if R has 
PDRING SYMBOL
 differentiate : (%,Symbol,NonNegativeInteger) -> % if R has PDRING SYMBOL
 differentiate : (%,List Symbol) -> % if R has PDRING SYMBOL
 differentiate : (%,Symbol) -> % if R has PDRING SYMBOL
 differentiate : (%,NonNegativeInteger) -> % if R has DIFRING
 differentiate : % -> % if R has DIFRING
 ?.? : (%,R) -> % if R has ELTAB(R,R)
 eval : (%,Symbol,R) -> % if R has IEVALAB(SYMBOL,R)
 eval : (%,List Symbol,List R) -> % if R has IEVALAB(SYMBOL,R)
 eval : (%,List Equation R) -> % if R has EVALAB R
 eval : (%,Equation R) -> % if R has EVALAB R
 eval : (%,R,R) -> % if R has EVALAB R
 eval : (%,List R,List R) -> % if R has EVALAB R
 max : (%,%) -> % if R has ORDSET
 min : (%,%) -> % if R has ORDSET
 rational : % -> Fraction Integer if R has INS
 rational? : % -> Boolean if R has INS
 rationalIfCan : % -> Union(Fraction Integer,"failed") if R has INS
 reducedSystem : Matrix % -> Matrix R
 reducedSystem : (Matrix %,Vector %) -> Record(mat: Matrix R,vec: Vector R)
 reducedSystem : (Matrix %,Vector %) -> Record(mat: Matrix Integer,vec: 
Vector Integer) if R has LINEXP INT
 reducedSystem : Matrix % -> Matrix Integer if R has LINEXP INT
 retract : % -> Fraction Integer if R has RETRACT FRAC INT
 retract : % -> Integer if R has RETRACT INT
 retractIfCan : % -> Union(R,"failed")
 retractIfCan : % -> Union(Fraction Integer,"failed") if R has RETRACT 
FRAC INT
 retractIfCan : % -> Union(Integer,"failed") if R has RETRACT INT
 subtractIfCan : (%,%) -> Union(%,"failed")

(1) -> )help Quaternion
====================================================================
Quaternion examples
====================================================================

The domain constructor Quaternion implements quaternions over
commutative rings.

The basic operation for creating quaternions is quatern.  This is a
quaternion over the rational numbers.

  q := quatern(2/11,-8,3/4,1)
     2        3
    -- - 8i + - j + k
    11        4
                        Type: Quaternion Fraction Integer

The four arguments are the real part, the i imaginary part, the j
imaginary part, and the k imaginary part, respectively.

  [real q, imagI q, imagJ q, imagK q]
      2     3
    [--,- 8,-,1]
     11     4
                        Type: List Fraction Integer

Because q is over the rationals (and nonzero), you can invert it.

  inv q
      352     15488      484       1936
    ------ + ------ i - ----- j - ------ k
    126993   126993     42331     126993
                        Type: Quaternion Fraction Integer

The usual arithmetic (ring) operations are available

  q^6
      2029490709319345   48251690851     144755072553     48251690851
    - ---------------- - ----------- i + ------------ j + ----------- k
         7256313856        1288408         41229056         10307264
                        Type: Quaternion Fraction Integer

  r := quatern(-2,3,23/9,-89); q + r
      20        119
    - -- - 5i + --- j - 88k
      11         36
                        Type: Quaternion Fraction Integer

In general, multiplication is not commutative.

  q * r - r * q
      2495             817
    - ---- i - 1418j - --- k
       18               18
                         Type: Quaternion Fraction Integer

There are no predefined constants for the imaginary i, j, and k parts,
but you can easily define them.

  i:=quatern(0,1,0,0)
    i
                         Type: Quaternion Integer

  j:=quatern(0,0,1,0)
    j
                         Type: Quaternion Integer
 
  k:=quatern(0,0,0,1)
    k
                         Type: Quaternion Integer

These satisfy the normal identities.

  [i*i, j*j, k*k, i*j, j*k, k*i, q*i]
                             2         3
     [- 1,- 1,- 1,k,i,j,8 + -- i + j - - k]
                            11         4
                          Type: List Quaternion Fraction Integer

The norm is the quaternion times its conjugate.

  norm q
    126993
    ------
     1936
                          Type: Fraction Integer

  conjugate q
      2        3
     -- + 8i - - j - k
     11        4
                          Type: Quaternion Fraction Integer

  q * %
     126993
     ------
      1936
                          Type: Quaternion Fraction Integer

See Also:
o )help Octonion
o )help Complex
o )help CliffordAlgebra
o )show Quaternion

(1) -> )sys cat int/input/Quaternion.output
Starts dribbling to Quaternion.output (2009/10/29, 7:36:17).
)set message test on
 
)set message auto off
 
)clear all
 
--S 1 of 13
q := quatern(2/11,-8,3/4,1)
 

         2        3
   (1)  -- - 8i + - j + k
        11        4
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R         2        3
--R   (1)  -- - 8i + - j + k
--R        11        4
--R                                            Type: Quaternion Fraction 
Integer
--E 1

--S 2 of 13
[real q, imagI q, imagJ q, imagK q]
 

          2     3
   (2)  [--,- 8,-,1]
         11     4
                                                  Type: List Fraction 
Integer
--R
--R
--R          2     3
--R   (2)  [--,- 8,-,1]
--R         11     4
--R                                                  Type: List Fraction 
Integer
--E 2

--S 3 of 13
inv q
 

          352     15488      484       1936
   (3)  ------ + ------ i - ----- j - ------ k
        126993   126993     42331     126993
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          352     15488      484       1936
--R   (3)  ------ + ------ i - ----- j - ------ k
--R        126993   126993     42331     126993
--R                                            Type: Quaternion Fraction 
Integer
--E 3

--S 4 of 13
q^6
 

          2029490709319345   48251690851     144755072553     48251690851
   (4)  - ---------------- - ----------- i + ------------ j + ----------- k
             7256313856        1288408         41229056         10307264
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          2029490709319345   48251690851     144755072553     48251690851
--R   (4)  - ---------------- - ----------- i + ------------ j + 
----------- k
--R             7256313856        1288408         41229056         10307264
--R                                            Type: Quaternion Fraction 
Integer
--E 4

--S 5 of 13
r := quatern(-2,3,23/9,-89); q + r
 

          20        119
   (5)  - -- - 5i + --- j - 88k
          11         36
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          20        119
--R   (5)  - -- - 5i + --- j - 88k
--R          11         36
--R                                            Type: Quaternion Fraction 
Integer
--E 5

--S 6 of 13
q * r - r * q
 

          2495             817
   (6)  - ---- i - 1418j - --- k
           18               18
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          2495             817
--R   (6)  - ---- i - 1418j - --- k
--R           18               18
--R                                            Type: Quaternion Fraction 
Integer
--E 6

--S 7 of 13
i:=quatern(0,1,0,0)
 

   (7)  i
                                                     Type: Quaternion 
Integer
--R
--R
--R   (7)  i
--R                                                     Type: Quaternion 
Integer
--E 7

--S 8 of 13
j:=quatern(0,0,1,0)
 

   (8)  j
                                                     Type: Quaternion 
Integer
--R
--R
--R   (8)  j
--R                                                     Type: Quaternion 
Integer
--E 8

--S 9 of 13
k:=quatern(0,0,0,1)
 

   (9)  k
                                                     Type: Quaternion 
Integer
--R
--R
--R   (9)  k
--R                                                     Type: Quaternion 
Integer
--E 9

--S 10 of 13
[i*i, j*j, k*k, i*j, j*k, k*i, q*i]
 

                                 2         3
   (10)  [- 1,- 1,- 1,k,i,j,8 + -- i + j - - k]
                                11         4
                                       Type: List Quaternion Fraction 
Integer
--R
--R
--R                                 2         3
--R   (10)  [- 1,- 1,- 1,k,i,j,8 + -- i + j - - k]
--R                                11         4
--R                                       Type: List Quaternion Fraction 
Integer
--E 10

--S 11 of 13
norm q
 

         126993
   (11)  ------
          1936
                                                       Type: Fraction 
Integer
--R
--R
--R         126993
--R   (11)  ------
--R          1936
--R                                                       Type: Fraction 
Integer
--E 11

--S 12 of 13
conjugate q
 

          2        3
   (12)  -- + 8i - - j - k
         11        4
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          2        3
--R   (12)  -- + 8i - - j - k
--R         11        4
--R                                            Type: Quaternion Fraction 
Integer
--E 12

--S 13 of 13
q * %
 

         126993
   (13)  ------
          1936
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R         126993
--R   (13)  ------
--R          1936
--R                                            Type: Quaternion Fraction 
Integer
--E 13
)spool
 
(1) ->

                        AXIOM Computer Algebra System
                       Version: Axiom (September 2009)
              Timestamp: Thursday October 29, 2009 at 06:43:59
-----------------------------------------------------------------------------
   Issue )copyright to view copyright notices.
   Issue )summary for a summary of useful system commands.
   Issue )quit to leave AXIOM and return to shell.
-----------------------------------------------------------------------------
 
   Re-reading compress.daase   Re-reading interp.daase
   Re-reading operation.daase
   Re-reading category.daase
   Re-reading browse.daase
(1) ->
(1) -> )display operation makeprod

There is one unexposed function called makeprod :
   [1] (D1,D2) -> Product(D1,D2) from Product(D1,D2)
            if D1 has SETCAT and D2 has SETCAT

Examples of makeprod from Product

f:=(x:INT):INT +-> 3*x
g:=(x:INT):INT +-> x^3
h(x:INT):Product(INT,INT) == makeprod(f x, g x)
h(3)

(1) -> )show Quaternion
 Quaternion R: CommutativeRing  is a domain constructor
 Abbreviation for Quaternion is QUAT
 This constructor is exposed in this frame.
 Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for QUAT

------------------------------- Operations --------------------------------
 ?*? : (R,%) -> %                      ?*? : (%,R) -> %
 ?*? : (%,%) -> %                      ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %        ?**? : (%,PositiveInteger) -> %
 ?+? : (%,%) -> %                      ?-? : (%,%) -> %
 -? : % -> %                           ?=? : (%,%) -> Boolean
 D : (%,(R -> R)) -> %                 D : % -> % if R has DIFRING
 1 : () -> %                           0 : () -> %
 ?^? : (%,PositiveInteger) -> %        abs : % -> R if R has RNS
 coerce : R -> %                       coerce : Integer -> %
 coerce : % -> OutputForm              conjugate : % -> %
 hash : % -> SingleInteger             imagI : % -> R
 imagJ : % -> R                        imagK : % -> R
 inv : % -> % if R has FIELD           latex : % -> String
 map : ((R -> R),%) -> %               norm : % -> R
 one? : % -> Boolean                   quatern : (R,R,R,R) -> %
 real : % -> R                         recip : % -> Union(%,"failed")
 retract : % -> R                      sample : () -> %
 zero? : % -> Boolean                  ?~=? : (%,%) -> Boolean
 ?*? : (Fraction Integer,%) -> % if R has FIELD
 ?*? : (%,Fraction Integer) -> % if R has FIELD
 ?*? : (NonNegativeInteger,%) -> %
 ?**? : (%,Integer) -> % if R has FIELD
 ?**? : (%,NonNegativeInteger) -> %
 ?<? : (%,%) -> Boolean if R has ORDSET
 ?<=? : (%,%) -> Boolean if R has ORDSET
 ?>? : (%,%) -> Boolean if R has ORDSET
 ?>=? : (%,%) -> Boolean if R has ORDSET
 D : (%,(R -> R),NonNegativeInteger) -> %
 D : (%,List Symbol,List NonNegativeInteger) -> % if R has PDRING SYMBOL
 D : (%,Symbol,NonNegativeInteger) -> % if R has PDRING SYMBOL
 D : (%,List Symbol) -> % if R has PDRING SYMBOL
 D : (%,Symbol) -> % if R has PDRING SYMBOL
 D : (%,NonNegativeInteger) -> % if R has DIFRING
 ?^? : (%,Integer) -> % if R has FIELD
 ?^? : (%,NonNegativeInteger) -> %
 characteristic : () -> NonNegativeInteger
 charthRoot : % -> Union(%,"failed") if R has CHARNZ
 coerce : Fraction Integer -> % if R has FIELD or R has RETRACT FRAC INT
 convert : % -> InputForm if R has KONVERT INFORM
 differentiate : (%,(R -> R)) -> %
 differentiate : (%,(R -> R),NonNegativeInteger) -> %
 differentiate : (%,List Symbol,List NonNegativeInteger) -> % if R has 
PDRING SYMBOL
 differentiate : (%,Symbol,NonNegativeInteger) -> % if R has PDRING SYMBOL
 differentiate : (%,List Symbol) -> % if R has PDRING SYMBOL
 differentiate : (%,Symbol) -> % if R has PDRING SYMBOL
 differentiate : (%,NonNegativeInteger) -> % if R has DIFRING
 differentiate : % -> % if R has DIFRING
 ?.? : (%,R) -> % if R has ELTAB(R,R)
 eval : (%,Symbol,R) -> % if R has IEVALAB(SYMBOL,R)
 eval : (%,List Symbol,List R) -> % if R has IEVALAB(SYMBOL,R)
 eval : (%,List Equation R) -> % if R has EVALAB R
 eval : (%,Equation R) -> % if R has EVALAB R
 eval : (%,R,R) -> % if R has EVALAB R
 eval : (%,List R,List R) -> % if R has EVALAB R
 max : (%,%) -> % if R has ORDSET
 min : (%,%) -> % if R has ORDSET
 rational : % -> Fraction Integer if R has INS
 rational? : % -> Boolean if R has INS
 rationalIfCan : % -> Union(Fraction Integer,"failed") if R has INS
 reducedSystem : Matrix % -> Matrix R
 reducedSystem : (Matrix %,Vector %) -> Record(mat: Matrix R,vec: Vector R)
 reducedSystem : (Matrix %,Vector %) -> Record(mat: Matrix Integer,vec: 
Vector Integer) if R has LINEXP INT
 reducedSystem : Matrix % -> Matrix Integer if R has LINEXP INT
 retract : % -> Fraction Integer if R has RETRACT FRAC INT
 retract : % -> Integer if R has RETRACT INT
 retractIfCan : % -> Union(R,"failed")
 retractIfCan : % -> Union(Fraction Integer,"failed") if R has RETRACT 
FRAC INT
 retractIfCan : % -> Union(Integer,"failed") if R has RETRACT INT
 subtractIfCan : (%,%) -> Union(%,"failed")

(1) -> )help Quaternion
====================================================================
Quaternion examples
====================================================================

The domain constructor Quaternion implements quaternions over
commutative rings.

The basic operation for creating quaternions is quatern.  This is a
quaternion over the rational numbers.

  q := quatern(2/11,-8,3/4,1)
     2        3
    -- - 8i + - j + k
    11        4
                        Type: Quaternion Fraction Integer

The four arguments are the real part, the i imaginary part, the j
imaginary part, and the k imaginary part, respectively.

  [real q, imagI q, imagJ q, imagK q]
      2     3
    [--,- 8,-,1]
     11     4
                        Type: List Fraction Integer

Because q is over the rationals (and nonzero), you can invert it.

  inv q
      352     15488      484       1936
    ------ + ------ i - ----- j - ------ k
    126993   126993     42331     126993
                        Type: Quaternion Fraction Integer

The usual arithmetic (ring) operations are available

  q^6
      2029490709319345   48251690851     144755072553     48251690851
    - ---------------- - ----------- i + ------------ j + ----------- k
         7256313856        1288408         41229056         10307264
                        Type: Quaternion Fraction Integer

  r := quatern(-2,3,23/9,-89); q + r
      20        119
    - -- - 5i + --- j - 88k
      11         36
                        Type: Quaternion Fraction Integer

In general, multiplication is not commutative.

  q * r - r * q
      2495             817
    - ---- i - 1418j - --- k
       18               18
                         Type: Quaternion Fraction Integer

There are no predefined constants for the imaginary i, j, and k parts,
but you can easily define them.

  i:=quatern(0,1,0,0)
    i
                         Type: Quaternion Integer

  j:=quatern(0,0,1,0)
    j
                         Type: Quaternion Integer
 
  k:=quatern(0,0,0,1)
    k
                         Type: Quaternion Integer

These satisfy the normal identities.

  [i*i, j*j, k*k, i*j, j*k, k*i, q*i]
                             2         3
     [- 1,- 1,- 1,k,i,j,8 + -- i + j - - k]
                            11         4
                          Type: List Quaternion Fraction Integer

The norm is the quaternion times its conjugate.

  norm q
    126993
    ------
     1936
                          Type: Fraction Integer

  conjugate q
      2        3
     -- + 8i - - j - k
     11        4
                          Type: Quaternion Fraction Integer

  q * %
     126993
     ------
      1936
                          Type: Quaternion Fraction Integer

See Also:
o )help Octonion
o )help Complex
o )help CliffordAlgebra
o )show Quaternion

(1) -> )sys cat int/input/Quaternion.output
Starts dribbling to Quaternion.output (2009/10/29, 7:36:17).
)set message test on
 
)set message auto off
 
)clear all
 
--S 1 of 13
q := quatern(2/11,-8,3/4,1)
 

         2        3
   (1)  -- - 8i + - j + k
        11        4
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R         2        3
--R   (1)  -- - 8i + - j + k
--R        11        4
--R                                            Type: Quaternion Fraction 
Integer
--E 1

--S 2 of 13
[real q, imagI q, imagJ q, imagK q]
 

          2     3
   (2)  [--,- 8,-,1]
         11     4
                                                  Type: List Fraction 
Integer
--R
--R
--R          2     3
--R   (2)  [--,- 8,-,1]
--R         11     4
--R                                                  Type: List Fraction 
Integer
--E 2

--S 3 of 13
inv q
 

          352     15488      484       1936
   (3)  ------ + ------ i - ----- j - ------ k
        126993   126993     42331     126993
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          352     15488      484       1936
--R   (3)  ------ + ------ i - ----- j - ------ k
--R        126993   126993     42331     126993
--R                                            Type: Quaternion Fraction 
Integer
--E 3

--S 4 of 13
q^6
 

          2029490709319345   48251690851     144755072553     48251690851
   (4)  - ---------------- - ----------- i + ------------ j + ----------- k
             7256313856        1288408         41229056         10307264
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          2029490709319345   48251690851     144755072553     48251690851
--R   (4)  - ---------------- - ----------- i + ------------ j + 
----------- k
--R             7256313856        1288408         41229056         10307264
--R                                            Type: Quaternion Fraction 
Integer
--E 4

--S 5 of 13
r := quatern(-2,3,23/9,-89); q + r
 

          20        119
   (5)  - -- - 5i + --- j - 88k
          11         36
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          20        119
--R   (5)  - -- - 5i + --- j - 88k
--R          11         36
--R                                            Type: Quaternion Fraction 
Integer
--E 5

--S 6 of 13
q * r - r * q
 

          2495             817
   (6)  - ---- i - 1418j - --- k
           18               18
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          2495             817
--R   (6)  - ---- i - 1418j - --- k
--R           18               18
--R                                            Type: Quaternion Fraction 
Integer
--E 6

--S 7 of 13
i:=quatern(0,1,0,0)
 

   (7)  i
                                                     Type: Quaternion 
Integer
--R
--R
--R   (7)  i
--R                                                     Type: Quaternion 
Integer
--E 7

--S 8 of 13
j:=quatern(0,0,1,0)
 

   (8)  j
                                                     Type: Quaternion 
Integer
--R
--R
--R   (8)  j
--R                                                     Type: Quaternion 
Integer
--E 8

--S 9 of 13
k:=quatern(0,0,0,1)
 

   (9)  k
                                                     Type: Quaternion 
Integer
--R
--R
--R   (9)  k
--R                                                     Type: Quaternion 
Integer
--E 9

--S 10 of 13
[i*i, j*j, k*k, i*j, j*k, k*i, q*i]
 

                                 2         3
   (10)  [- 1,- 1,- 1,k,i,j,8 + -- i + j - - k]
                                11         4
                                       Type: List Quaternion Fraction 
Integer
--R
--R
--R                                 2         3
--R   (10)  [- 1,- 1,- 1,k,i,j,8 + -- i + j - - k]
--R                                11         4
--R                                       Type: List Quaternion Fraction 
Integer
--E 10

--S 11 of 13
norm q
 

         126993
   (11)  ------
          1936
                                                       Type: Fraction 
Integer
--R
--R
--R         126993
--R   (11)  ------
--R          1936
--R                                                       Type: Fraction 
Integer
--E 11

--S 12 of 13
conjugate q
 

          2        3
   (12)  -- + 8i - - j - k
         11        4
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R          2        3
--R   (12)  -- + 8i - - j - k
--R         11        4
--R                                            Type: Quaternion Fraction 
Integer
--E 12

--S 13 of 13
q * %
 

         126993
   (13)  ------
          1936
                                            Type: Quaternion Fraction 
Integer
--R
--R
--R         126993
--R   (13)  ------
--R          1936
--R                                            Type: Quaternion Fraction 
Integer
--E 13
)spool
 
(1) ->

\start
Date: Fri, 30 Oct 2009 12:26:14 +0000
From: Bertfried Fauser
To: Martin Baker
Subject: Re: [Axiom-mail] finding source code

Hi Martin,

> So yes, I am interested, but I don't know how much I could do.

OK, I got this disclaimer, anybody states it :-))

> As I say, I don't have a rigorous mathematical background,

No worries, most things with Clifford algebras are easy.

Clifford and Grassmann bases:

Mathematically its sound to start with the Grassmann algebra, you have
the following ingrediences:

V an n-dim vector space
/\ : V x V ... x V --> /\^n V  the unital, associative antisymmetric
   exterior product or Grassmann or wedge product (all sysnonyms)

Due to antisymmetry you have for ever v in V that   v/\v=3D0, however,
if w<>\alpha v then w/\v is a _new_ element of the algebra. Choosing
a (any) basis {ei}_i in V allows you to construct 2^n many basis elements.
Hence the algebra relations for a grassmann algebra is

Grassmann:   v/\v =3D0 for all v \in V
  <=3D>     ei/\ej =3D -ej/\ei    (by setting v=3Dei+ej) and using ei/\ei=
=3D0 etc)

You have (n over 0) 0-vectors (the scalars of the base field times
identity of the algebra)
You have (n over 1) 1-vectors, that are the images of the base vectors
ei in the alegbra,
     often these immages are not distingusihed from ther orignal basis
verctor life.
You have (n over 2) 2-vectors (bi-vectors) of type ei/\ej  i<j,
...
You have (n over n) =3D 1 n-vector (volume form) e1/\e2/\ ../\en

A vector fron the space of k-vectors is said to have degree/step/grade k

Any Grassmann alegbra element is written as a linear combination in this
2^n=3D\sum_k (n over k) many vector space generators (basis elements)
[Note the algebra generators are the ei only]

Geometric information is attached to the so-called decomposable
tensors (externsors,
blades,...)  So v/\w may be a line [_or_ an area], but  w/\v + x/\y is
not a generic
geometric object.

Clifford algebra:
  Ingredients are now: V the same vector space as above with basis {ei}_i a=
nd
a quadratic form (which I use in its polarized matrix form) hence Q~=3Dsymm=
etric
matrix G over the base field. The algebra relations are now

Clifford:
   we still have   ei/\ej =3D -ej/\ei  for i<>j
   but add         ei^2=3DQ(ei) =3D ei^t G ei  (last expression is matrix
dot product, ei^t row
                        vector)

  This set of rules _implies_ that the matrix G of the bilinear form Q
is diagonal in the
basis {ei}_i, we want a more general setting allowing any basis of V
to be used. This
is most easily done using a construction from Chevalley:

Let \gamma : V ----> (End /\V ~=3D) CL(V,G)    (again G~=3DQ) be a map
which injects the space V into the Clifford algebra CL(V,G)

We define \gamma with values in the endomorphisms of the grassmann algebra
build over V as follows (=B0 =3D clifford product):

\gamma(1)  =3D 1=B0
\gamma(ei) =3D Ei=B0 =3D Ei/\ +  Ei _|

where Ei _| Ej :=3D Ei^t G Ej   for Ei in (the image of) V
_| is called contraction, one sees that the Clifford product has two
parts, the exterior part and the contraction part which depends on G.
If G=3D0 the the Clifford algebra becomes a Grassmann algebra.

Furthermore do we see that the Clifford algebra has a basis out of Grassman=
n
elements.  GL(V,G) ~=3D /\V as vector spaces (not als algebras)

lets proceed with gamma:

\gamma(ei/\ej) =3D (Ei /\ Ej)=B0 =3D (Ei =B0 Ej)=B0 -  (Ei _| Ej)=B0
   =3D (Ei =B0 Ej)=B0 -  (E_i^t G Ej) 1=B0

ect in a recursive way. This allows to construct the clifford product in
in terms of a Grassmann basis and to obtain the general multiplication

u1/\.../\uk =B0  v1/\../\vl =3D many terms of degree k+l   to abs(k-l)

For your example we have
          [  0   1  ]
G : =3D   [  1   0  ]
which gives (I switch back to ei for Clifford and Grassmann)

e1 =B0 e1 =3D e1/\e1 + e1^t G e1 =3D 0
e1 =B0 e2 =3D e1/\e2 + e1^t G e2 =3D e1/\e2 + 1   (note this is no longer h=
omogeneous)
                                                               (e1 =B0
e2 has degree 0 and degree 2 parts)
e2 =B0 e1 =3D e2/\e1 + e2^t G e1 =3D -e1/\e2 + 1
e2 =B0 e2 =3D e2/\e2 + e2^t G e2 =3D 0

A bit more complicated is:

e1 =B0 (e1/\e2) =3D e1/\e1/\e2 + e1_| (e1/\e2)   first term is zero due to =
e1/\e1=3D0
the second term need some thought, the bilinear form G acts only on VxV,
now we need to know how it acts on elements of V/\V, this is done by demand=
ing
that _| is a (graded) derivation

e1 =B0 (e1/\e2) =3D (e1 _| e1) /\e2  + (-1)^(degree(e1)*degree(e1)) e1/\(e1=
 _| e2)
                      ^^^^^^^^ zero                (-1)^1*1
               ^^^^^^^one
      =3D -e1

similarly we get

e2  =B0 (e1/\e2) =3D e2

(e1/\e2) =B0 e1 is obtained by rewriting e1/\e2 =3D e1=B0e2 - e1_|e2 and
applying the needed
simplifications, .....

> In other words the two bases are the same when the inner product is in it=
s
> diagonal form but when the bases are rotated the outer product rotated wi=
th it
> only in the case of Grassmann basis but not in the case of the Clifford b=
asis?

No, not really. you may address a grassmann algebra as a special
clifford algebra
with Q=3D0 (mathematically a bit sloppy but helpful)

The point is that you need to watch what kind of product you use to
generate your
algebra. Grassmann uses /\, but Clifford has two choices, =B0 and /\.
geometry needs
the /\basis but AXIOM uses the =B0 basis and assumes that the quadratic for=
m is
diagonal in the basis of generators (AFAIK).

1=3D1,  ei =3D ei  of course

ei/\ej       =3D/=3D  ei=B0ej =3D ei/\ej + ei^t G e_j
ei/\ej/\ek  =3D/=3D  ei=B0ej=B0ek =3D ei=B0(ej/\ek + ej^t G e_k)
                      =3D ei/\ej/\ek  + ei^t G e_j ek - ek  ei^t G ek +
ej ei^t G ek

If you write in AXIOM ei*ej, you get ei=B0ej and not ei/\ej + ei^t G ej  et=
c...

> I need to think more about your comments about projective space and confo=
rmal
> model (It takes me some time to absorb these things)

I think in the works you mentioned, these things should be described,
otherwise look
on the arXiv for work of John Seelig, and Joan Lasenby....

> the purposes of Axiom, the code would need to be completely general and n=
ot
> otpimised for particular geometries?

That's not really true. You _just_ need a Clifford algebra, the
geometry comes as
a sort of interpretation of the objects (elements) in the algebra.
What would be needed
is the following [Hence a clifford algebra is not geometric, its the
interpretation]

1)  a grassmann basis for the clifford algebra
2) the exteriorn /\ product, contraction _| and a proper clifford product =
=B0
3) some device to generate matrices out of clifford numbers and vice versa
4) possibly a clifford solver which allows to type in equations in
clifford variables
   so that you get a solution set, eg: X a generic element in CL(V,Q), find=
 all
   X with (X^2=3D) X=B0X =3D X

That's almost all one needs (without spinors)

\start
Date: Fri, 30 Oct 2009 11:12:40 -0400
From: Bill Page
To: Bertfried Fauser
Subject: re: [Axiom-mail] finding source code
Cc: Martin Baker

Bertfried,

I think it's great to have this quick introduction - especially when
it also references what is currently implemented in Axiom and what
might be done in the future.  I hope that we can eventually have a
tutorial including actual Axiom code. If you start to develop
something like that I would be very glad to help add it to the
axiom-wiki.newsynthesis.org web site!

On Fri, Oct 30, 2009 at 8:26 AM, Bertfried Fauser wrote:
> Hi Martin,
>
>> So yes, I am interested, but I don't know how much I could do.
>
> OK, I got this disclaimer, anybody states it :-))
>
>> As I say, I don't have a rigorous mathematical background,
>
> No worries, most things with Clifford algebras are easy.
>
> Clifford and Grassmann bases:
>
> Mathematically its sound to start with the Grassmann algebra, you have
> the following ingrediences:
>
> V an n-dim vector space
> /\ : V x V ... x V --> /\^n V =A0the unital, associative antisymmetric
> =A0 exterior product or Grassmann or wedge product (all sysnonyms)
>
> ...

Although I think your somewhat more formal approach is very important
in the context of Axiom, you might also be interested in the more
applied approach presented by John Browne here:

http://sites.google.com/site/grassmannalgebra/bookandpackageversions

"This Grassmann algebra project has been a part-time project dating
from my doctoral thesis in the area in 1978. In October 2001 I
published an incomplete book draft "Grassmann Algebra: Exploring
applications of extended vector algebra with Mathematica" on my
university home page. The computations in this draft were done with
early versions of Mathematica and draft versions of the
GrassmannAlgebra package. ..."

John also makes his Mathematica code available online. It would be
great to have this kind of package available in Axiom.

\start
Date: Fri, 30 Oct 2009 14:48:12 -0500
From: Tim Daly
To: Franz Lehner
Subject: Examples on functions

Franz,

 > 2. On the download page for release 1.0.8 there is a tarball containing
 > examples. Where should they go to make them visible to )help ?

If you put a flat text file in $AXIOM/doc/spadhelp, for example,
create a file called $AXIOM/doc/spadhelp/foo.help then you can say

  )help foo

and it will type out the contents of that file. I have created
about 300 help files (which will also work in Fricas).

If you create new help files I would be happy to add them.


 > 3. What is a canonical place to put examples?
 > In Axiom (TM) there are some examples shown after the )display command,
 > which can be quite instructive.
 > I would like to prepare some examples for tensor as well.

In Axiom you can add examples to any function. The examples are just
a special syntax in the comments for a function. So if you have a
function called

    foo: % -> %
      ++ foo(x) returns x

then you can write an example by adding "++X" comments (that is,
the ++ comment followed immediately by an "X" character so you write:

   foo: % -> %
     ++ foo(x) returns x
     ++
     ++X foo(3)

Fricas could add this functionality easily but I'm not part of that
effort so someone will have to pick up the change from Axiom and
add it to Fricas.


On another topic, Axiom algebra is integrating the regression test
files with the algebra sources. If you generate new code I beg you
to write as many tests as you can, especially including a test for
each function. It is very painful for me to try to track Fricas
algebra because all I ever see is the final code with no test
cases, documentation, examples, or pointers to literature. This
makes it very difficult for me (or anyone, actually) to figure
out how to use new algebra.

\start
Date: Fri, 30 Oct 2009 21:46:42 +0000
From: Bertfried Fauser
To: Tim Daly
Subject: Re: Examples on functions
Cc: Franz Lehner

Dear Tim,

> On another topic, Axiom algebra is integrating the regression test
> files with the algebra sources. If you generate new code I beg you
> to write as many tests as you can, especially including a test for
> each function.

I try to comply with this rule (ralf also asked for documentation) for
the symmetric functions and hope they make their way into AXIOM(TM)
too.

However a fully documeted code is out of my working power, there is just far too
much to say about symmetric functions.

You saw possibly the mail of Martin on Clifford algebras. I have tried
to test some Clifford issues in FriCAS (no AXIOM(TM) on my computer
currently) but that should be identical. FriCAS is assuming that the
quadratic form is diagonal, that is very bad.  Perhaps I will find
time to improve that. I tried to put up a sandbox on newsynthesis, but
I possibyl forgot my user paseword there, since the system didn't let
me create a new sandbox

\start
Date: Fri, 30 Oct 2009 17:42:15 -0500
From: Tim Daly
To: Bertfried Fauser
Subject: Re: Examples on functions
Cc: Franz Lehner

Bertfried Fauser wrote:
> Dear Tim,
>
>   
>> On another topic, Axiom algebra is integrating the regression test
>> files with the algebra sources. If you generate new code I beg you
>> to write as many tests as you can, especially including a test for
>> each function.
>>     
>
> I try to comply with this rule (ralf also asked for documentation) for
> the symmetric
> functions and hope they make their way into AXIOM(TM) too.
>
> However a fully documeted code is out of my working power, there is just far too
> much to say about symmetric functions.
>
> You saw possibly the mail of Martin on Clifford algebras. I have tried
> to test some
> Clifford issues in FriCAS (no AXIOM(TM) on my computer currently) but
> that should
> be identical. FriCAS is assuming that the quadratic form is diagonal,
> that is very bad.
> Perhaps I will find time to improve that. I tried to put up a sandbox
> on newsynthesis,
> but I possibyl forgot my user paseword there, since the system didn't
> let me create
> a new sandbox
>
> Ciao
> BF.
>
>   
Given working tests we have some hope of figuring out what a function
is supposed to do. Without a working test we can only guess whether the
answer is right or not. You certainly have to construct these simple
test cases in order to debug your code. Save the tests you do.

As for documentation, it helps to include a small paragraph that
contains enough so that we can find the rest in the literature.
Even something as simple as a link to Eric's mathworld or wikipedia
or a book reference would be a start. When I worked on the special
function E1 at least there was a reference to Luke's book. Nobody
can really expect you to write a tutorial or a book chapter but
references help a lot.

I'm trying to avoid just a straight "code dump" because then we
have to guess. The main reason I started added example output to
the ")display operation" command is that the new user would have
at least one working example of every function. Sometimes it is
very hard to construct the Axiom type even if you know what the
input should look like, which I'm sure you have experienced.

\start
Date: Sat, 31 Oct 2009 00:31:40 +0100
From: Ralf Hemmecke
To: Tim Daly
Subject: Re: Examples on functions
Cc: Franz Lehner, Bertfried Fauser

> As for documentation, it helps to include a small paragraph that
> contains enough so that we can find the rest in the literature.
> Even something as simple as a link to Eric's mathworld or wikipedia
> or a book reference would be a start. When I worked on the special
> function E1 at least there was a reference to Luke's book. Nobody
> can really expect you to write a tutorial or a book chapter but
> references help a lot.

I would like to strongly support that.

Mathematics is such a huge field and with current technology we have to 
means to at least include a URL to help people that want to review the 
code but don't know everything about the background (yes sometimes 
following different books lead to different code design). It is vital to 
at least give enough hints to the literature.

\start
Date: Sat, 31 Oct 2009 10:59:43 +0000
From: Martin Baker
To: Bertfried Fauser
Subject: Clifford Algebra Requirements

Bertfried,

In addition to the limitations of the current Clifford algebra implementation, 
that you explained, there also seem (to my untrained eye) to be performance 
issues. Also I wanted to get a feel for the general Axiom design methodology 
by picking a specific issue.

The current implementation seems to calculate the product of terms every time 
it is required when a multiplication is called. From a performance point of 
view it would seem much more efficient to calculate a multiplication table in 
the constructor which would make individual multiplications much faster. The 
original author also had this thought as the following comment is in the code:

-- The ei*ej products could instead be precomputed in
-- a (2**n)**2 multiplication table.

The entries in such a table (in the general Grassman case) would be quite 
complicated. Not just a single type but perhaps a sum of types with algebraic 
number multipliers.

I think, if I were designing such a system using a conventional object 
oriented program then, I would create a class for the multiplication table and 
also a class for individual table entries. I don't know if that's how things 
are done in Axiom?

I don't know enough about the mathematics but is seems to me that classes 
(domains) such as mutiplicationTable and multipicationTableEntry might have 
wider application for implementing other algebras?

Here I am really going to show up the gaps in my mathematical education but, 
could these things link back to more fundamental structures, for example could 
there be an inheritance hierarchy like:

ring
field
field which is a compound type
compound type which can be defined by a multiplication table.
clifford (Grassman) algebra

Is there someone who defines the overall structure of Axiom at this level?

What do you think would be the best approach to this?

\start
Date: Sat, 31 Oct 2009 09:51:07 -0500
From: Tim Daly
To: Martin Baker
Subject: Re: Clifford Algebra Requirements
Cc: Bertfried Fauser

Martin Baker wrote:
> Bertfried,
>
> In addition to the limitations of the current Clifford algebra implementation, 
> that you explained, there also seem (to my untrained eye) to be performance 
> issues. Also I wanted to get a feel for the general Axiom design methodology 
> by picking a specific issue.
>
> The current implementation seems to calculate the product of terms every time 
> it is required when a multiplication is called. From a performance point of 
> view it would seem much more efficient to calculate a multiplication table in 
> the constructor which would make individual multiplications much faster. The 
> original author also had this thought as the following comment is in the code:
>
> -- The ei*ej products could instead be precomputed in
> -- a (2**n)**2 multiplication table.
>
> The entries in such a table (in the general Grassman case) would be quite 
> complicated. Not just a single type but perhaps a sum of types with algebraic 
> number multipliers.
>
> I think, if I were designing such a system using a conventional object 
> oriented program then, I would create a class for the multiplication table and 
> also a class for individual table entries. I don't know if that's how things 
> are done in Axiom?
>
> I don't know enough about the mathematics but is seems to me that classes 
> (domains) such as mutiplicationTable and multipicationTableEntry might have 
> wider application for implementing other algebras?
>
> Here I am really going to show up the gaps in my mathematical education but, 
> could these things link back to more fundamental structures, for example could 
> there be an inheritance hierarchy like:
>
> ring
> field
> field which is a compound type
> compound type which can be defined by a multiplication table.
> clifford (Grassman) algebra
>
> Is there someone who defines the overall structure of Axiom at this level?
>
> What do you think would be the best approach to this?
>
> Martin
>
>
> _______________________________________________
> Axiom-developer mailing list
> list
> http://lists.nongnu.org/mailman/listinfo/axiom-developer
>
>   
Martin,

Structurally, Axiom rests on the categories which define the behavior
which is expected from domains which belong to the categories. For
instance, everything that belongs to SetCategory has to implement
equality.

Domains implement the methods required by the categories as well as
methods particular to themselves. Thus, it would seem that you would
define a category "field defined by multiplication table" which could
defines expected methods by all members (e.g. tableLookup(element,element))

The Grassman algebra domain would be a member of the category and thus
would be expected to implement such a method.

Alternatively you could create a category "field with cached results"
that required a "cacheLookup(element,element)".

The design is flexible. However, there should be a strong mathematical
basis for the choice of category structure. That said, there is the
"computational mathematics" issue that some ideas are implied purely
by performance rather than mathematical.

A graph of the category hierarchy is at:
http://axiom-developer.org/axiom-website/bookvol10.2full.html

This is one of the more challenging aspects of Axiom so don't feel
intimidated by the task. Feel free to ask more questions.

I downloaded the Grassman Algebra book and have finished the first
two chapters. I looked at Grassman a couple years ago while I was
busy documenting the Quaternions.

\start
Date: Sat, 31 Oct 2009 16:13:43 +0000
From: Bertfried Fauser
To: Martin Baker
Subject: Re: Clifford Algebra Requirements

Dear Martin,

I am surely not the person to aks for general AXIOM(TM) designs, since I am
a novice on that either

> The current implementation seems to calculate the product of terms every time
> it is required when a multiplication is called. From a performance point of
> view it would seem much more efficient to calculate a multiplication table

This will work for very small diemnions. In my maple Clifford package
(with Rafal Ablamowicz) we tried to do that, and we were not able to
compute the multiplication tables for dim V > 8, since they become
_very_ huge. A partial solution is to cache the results of such
multiplications and to read results from the cache if present. There
si currently a discussion going of on teh FriCAS (AXIOM(TM) fork)
developers list how to do this properly. It seems that only certain
data structures can be cached and that one has to translate user data
structure possibyl into a Lisp expression which can be hashed. This is
surely nothing a novce user (as I feel to be) would like to crank.

> -- The ei*ej products could instead be precomputed in
> -- a (2**n)**2 multiplication table.

In principle yes, but if you have different bases, tha means also to store the
multipication table for each basis, which might soon become a problem.
Anyhow the first step is to _have_ a valid function which produces such a table,
then one can think of hashing.

> The entries in such a table (in the general Grassman case) would be quite
> complicated. Not just a single type but perhaps a sum of types with algebraic
> number multipliers.

That seems actually not to be a big issue, If we hash the product of two basis
elements, (Vector Integer, Vector Integer) the rsult is alway of type

CLQ  := Type: CliffordAlgebra(2,Fraction(Integer),[[1,0],[0,1]])
           <<CliffordAlgebra(dimension:Integer, Field, QuadraticForm)>>

so a table (Index,Index) -> CLQ would do the trick, I guess.

> oriented program then, I would create a class for the multiplication
> table and also a class for individual table entries. I don't know if
> that's how things are done in Axiom?

The table entries are from the domain CLQ, and there is a type Table(key,value)
in AXIOM.

> I don't know enough about the mathematics but is seems to me that classes
> (domains) such as mutiplicationTable and multipicationTableEntry might have
> wider application for implementing other algebras?

What one would need from the outset is a graedFreeModule(Ring,Basis) V
to model the Grassmann algebra. The Clifford algebra is (a sub alegbra of)
the endormiphism algebra of that, hence lives in the tensor product V (x) V^*

A general clifford elment is hence representet (inefficiently) by a sum of such
tensors.

> could these things link back to more fundamental structures, for example could
> there be an inheritance hierarchy like:
>
> ring
> field
> field which is a compound type
> compound type which can be defined by a multiplication table.
> clifford (Grassman) algebra

Indeed such hierarchies exist in AXIOM. However, one possibly needs
even modules over skew fields and I do not know if such things are implemented.

Complex Clifford algebra: CL(n)  has two cases n even and n odd
Real Clifford algebra. CL(p,q) has 8 cases where the base ring of the
representation
is in IL whre
IL={ reals, complex, quaternions, reals(+)reals, quaternios(+)quaternions}

If you would allow Clifford algebras to be build over, say finite
fields, or the integers,
I am not even sure there is a general classification result available.
Quadratic forms
(dim 2) with integral coefficients are classified by automorphic forms.....

> Is there someone who defines the overall structure of Axiom at this level?

Tim has sent you the link to the graph of AXIOM types, sacry isn't it?
But a grep on the sources sometimes points you to peices of code where
you can just see how other people made use of that.

> What do you think would be the best approach to this?

The first step would be to implement a solid version of the Grassmann
Hopf algebra.  (Hopf is automatic, i.e. in a mathematical sense
'universal'). After one can define a GrassmannH Hopf algebra (even
better and very much desirable Grassmann super Hopf algebra, i.e a
Grassmann algebra over a Z_2 graded module) one is ready to implement
the Clifford product (either using the Rota Stein Hopf algebra method,
used in Clifford with great effect) or the Chevalley recursive
definition (which is much slower for symbolic quadratic forms, which I
want to be able to use either).

So one would need to design an AXIOM(TM) category of the type

GrassmanSuperHopfAlegbra == ??
 where ?? has to be a gradedSuperModule(withBasis)(Ring,OrderedSet)

or such.... but I am not a category/domain specialist....

I am currently porting my SchurFkt package to AXIOM(TM) (FriCAS style)
and hope to improve my knowledge thereby to be able to implement such a
GrassmannSuperHopfAlgebraWithBasis after that enterprise...

Sorry for being unspecific, but that's due to my limited knowledge

\end{verbatim}
\eject
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
%\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{axiom}
\bibliography{axiom}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
%\phantomsection
\addcontentsline{toc}{chapter}{Index}
\printindex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
